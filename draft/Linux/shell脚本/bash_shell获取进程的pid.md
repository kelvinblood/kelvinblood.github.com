# bash shell获取进程的pid
[日期：2012-08-09] 	来源：Linux社区  作者：zbszhangbosen 	[字体：大 中 小]

在写一个脚本时在获取进程的pid时出现了一点点意外，当时的情境大概是这样的：跑一个任务A，然后任务B要监控A的状态，一旦A结束，B也要结束。当初第一反应就是获取B的pid然后判断A是否在运行，如果没有则kill掉B。可是当初就是不成功（用的是 $!），于是迫于任务紧急换了一种笨方法：让B的运行时间稍长于A任务（A任务的时间可以估算出来），于是就这样傻缺的开始了这个任务。

今天再一次有同样的需求，于是下定决心要弄明白上次为什么失败。后来终于发现了原因：当我们获取一个进程的pid时有一个最重要的条件：这个进程必须存在。当初大概的做法是这样的：

command A

comand B

pid=$!

if A is not exists

kill $pid

结果发现A运行完了但是B还在跑，那么这是什么原因呢？ 【Linux公社 http://www.linuxidc.com 】

因为command B 这种是阻塞式的命令，所以在B一直运行期间就将pid=$!阻塞住了，因此直到B运行完了pid=$!才能执行，而此时B已经运行完了，所以得到B的进程pid也就没有实际意义，因此最后pid的值实际上就是空了，因此接下来的kill $pid自然也就失败了。因此我们需要做的是command B&,让这个命令在后台运行，因此也就能让pid=$!执行，这样也就得到了上一个进程的pid。

这几天写脚本比较多，也出了很多错，总结起来就是bash shell脚本很容易因为细节问题而导致你意想不到的结果，因此在真正跑任务之前一定要模拟一点数据进行实践，否则等你期待的去分析脚本的结果时你会发现之前的白费功夫，浪费时间~